package edu.illinois.cs.cogcomp.lorelei;

import edu.illinois.cs.cogcomp.core.datastructures.Pair;
import edu.illinois.cs.cogcomp.core.io.LineIO;
import edu.illinois.cs.cogcomp.lbjava.parse.Parser;
import edu.illinois.cs.cogcomp.transliteration.SPModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.*;

/**
 * Created by mayhew2 on 5/5/16.
 */
public class WordPairReader implements Parser {

    private static Logger logger = LoggerFactory.getLogger( WordPairReader.class );

    public boolean islabeled = false;

    List<WordPair> wplist;
    int currcand = 0;

    private String TL_MODEL = "/home/mayhew2/IdeaProjects/illinois-transliteration/models/probs-Uyghur.txt";

    /**
     * This expects a string of form "(i, j)" where i and j are integers. Returns a pair.
     * @param s
     * @return  a pair that matches the string repr.
     */
    public static Pair<Integer, Integer> parseSpan(String s){
        s = s.replace("(", "");
        s = s.replace(")", "");
        s = s.replace(",", "");

        String[] ss = s.split(" ");

        return new Pair<>(Integer.parseInt(ss[0]), Integer.parseInt(ss[1]));
    }

    /**
     *
     * Load word pair candidates from candlines.txt.
     *
     * @param candfile candlines.txt, usually generated by {@link edu.illinois.cs.cogcomp.ner.data.ParallelToConll#getCandidates(String, String, String)}
     * @param condprobfile path to condprobs.txt (usually generated by fast_align).
     */
    public WordPairReader(String candfile, String condprobfile) {

        ArrayList<String> candlines = new ArrayList<>();
        try {
            candlines = LineIO.read(candfile);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        HashMap<Pair<String, String>, Double> condprobmap = new HashMap<>();

        try {
            List<String> condproblines = LineIO.read(condprobfile);

            for(String condprobline : condproblines){
                String[] sline = condprobline.split("\\s+");
                String eng = sline[0].toLowerCase();
                String forn = sline[1].toLowerCase();
                double score = Double.parseDouble(sline[2]);
                condprobmap.put(new Pair<>(eng, forn), score);
            }
        } catch (FileNotFoundException e) {

            e.printStackTrace();
        }

        // this is the set of annotated.
        wplist = new ArrayList<>();

        // Load the probs on the fly.
        SPModel transliterator = null;
        try {
            logger.info("Loading transliteration probs from: " + TL_MODEL);
            transliterator = new SPModel(TL_MODEL);
        } catch (IOException e) {
            e.printStackTrace();
        }

        HashMap<String, List<WordPair>> key2wps = new HashMap<>();

        int counter = 0;
        for(String cand : candlines) {

            if(counter % 1000 == 0){
                logger.debug("On " + counter + " out of " + candlines.size());
            }
            counter++;

            String[] scand = cand.split("\t");

            String fileid = scand[0];

            Pair<Integer, Integer> refspan = parseSpan(scand[2]);
            String refword = scand[3];
            String reflabel = scand[1];

            // loop over the rest of the line
            // 0,1,2,3 are the segmentid, type, span, and text.
            // each pair of span,text after that is a candidate.
            for (int i = 4; i < scand.length; i += 2) {
                Pair<Integer, Integer> span = parseSpan(scand[i]);
                String word = scand[i + 1];

                double score = 0;
                double tl_score = 0;
                // get score from condprob list.
                if(refword.split("\\s+").length == 1 && word.split("\\s+").length == 1){
                    Pair<String, String> p = new Pair<>(refword, word);
                    if(condprobmap.containsKey(p)){
                        score = condprobmap.get(p);
                        score = Math.exp(score);
                    }

                    tl_score = transliterator.Probability(refword.toLowerCase(), word.toLowerCase());
                }else{
                    // If either string has multiple tokens, get the best alignment score.
                    String[] sr = refword.split("\\s+");
                    String[] sw = word.split("\\s+");

                    if(sr.length == sw.length){
                        for(int j = 0; j < sr.length; j++){
                            String si = sr[j];
                            String sj = sw[j];
                            Pair<String, String> p = new Pair<>(si, sj);
                            if(condprobmap.containsKey(p)){
                                score +=  Math.exp(condprobmap.get(p));
                            }
                            tl_score += transliterator.Probability(si.toLowerCase(), sj.toLowerCase());
                        }
                        score /= sr.length;
                        tl_score /= sr.length;
                    }else{
                        logger.error("This shouldn't happen...");
                    }

//                    // for each word in english
//                    for(String si : sr){
//                        // best score for word si against any word in sw
//                        double simax = 0;
//                        for(String sj : sw){
//                            Pair<String, String> p = new Pair<>(si, sj);
//                            if(condprobmap.containsKey(p)){
//                                double pscore = Math.exp(condprobmap.get(p));
//                                if(pscore > simax){
//                                    simax = pscore;
//                                }
//                            }
//                        }
//                        score += simax;
//                    }
//                    score /= sr.length;
                }

                WordPair wp = new WordPair(fileid, refspan, refword, reflabel, span, word, score, tl_score);

                // Group wordpairs by key, so we can normalize the tl_scores.
                String k = wp.getKey();

                if(!key2wps.containsKey(k)){
                    key2wps.put(k, new ArrayList<WordPair>());
                }

                key2wps.get(k).add(wp);
            }
        }

        // TODO: populate wplist from the key2wps
        for(String key : key2wps.keySet()){
            List<WordPair> wps = key2wps.get(key);

            // get the max transliterationscore of these wordpairs. and divide all by that.
            double mx = 0;; // just needs to be nonzero.
            for(WordPair wp : wps){
                if(wp.transliterationprob > mx){
                    mx = wp.transliterationprob;
                }
            }

            // just don't allow tiny results...
            if(mx == 0){
                mx = 0.0000000001;
            }

            for(WordPair wp : wps){
                //wp.transliterationprob = wp.transliterationprob / mx;
                wplist.add(wp);
            }
        }

        logger.debug("Size of wplist: " + wplist.size());

    }

    /**
     * Just a convenience constructor. This calls {@link #WordPairReader(String, String)} and
     * then {@link #labelPairs(String)}.
     * @param candfile
     * @param condprobfile
     * @param trainingfile
     */
    public WordPairReader(String candfile, String condprobfile,String trainingfile) {
        this(candfile, condprobfile);
        labelPairs(trainingfile);
    }

    /**
     * Once the wplist is loaded, we will label each pair using a training file.
     * @param trainingfile
     */
    public void labelPairs(String trainingfile){
        islabeled = true;

        Random rand = new Random();

        ArrayList<String> traininglines = new ArrayList<>();
        try {
            traininglines = LineIO.read(trainingfile);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        // loop over candlines, if the doc+span is in traininglines, good, otherwise, continue.
        HashMap<String, Pair<String, String>> annotatedkeys = new HashMap<>();
        for(String line : traininglines){
            String[] sline = line.split("\t");
            String key = String.format("%s-%s-%s-%s", sline[0], sline[1], sline[2], sline[3]);
            // sline[4] is a span.
            annotatedkeys.put(key, new Pair<>(sline[4], sline[5]));
        }

        List<WordPair> wplistannotated = new ArrayList<>();

        int pos = 0;
        int neg = 0;
        for(WordPair wp : wplist){

            String key = wp.getKey();

            // only keep those lines that have annotations.
            if (annotatedkeys.containsKey(key)) {
                // this is the annotated version.
                Pair<String, String> oracle = annotatedkeys.get(key);

                if(oracle.getSecond().equals(wp.word) && oracle.getFirst().equals(wp.span.toString())){
                    wp.setMatch(true);
                }else{
                    wp.setMatch(false);
                }

                if(wp.match){
                    wplistannotated.add(wp);
                    pos++;
                }else if(rand.nextDouble() < 0.1){ // FIXME: what does this number do?? How is it set??
                    wplistannotated.add(wp);
                    neg++;
                }

            }
        }

        wplist = wplistannotated;
        logger.debug("Size of new wplist: " + wplist.size());
        logger.debug("pos: " + pos + ", neg: " + neg);
    }


    @Override
    public Object next() {
        if(currcand == wplist.size()){
            return null;
        }
        return wplist.get(currcand++);
    }

    @Override
    public void reset() {
        currcand = 0;
    }

    @Override
    public void close() {

    }

    public static void main(String[] args) throws FileNotFoundException {
        String dir = "/shared/corpora/ner/parallel/";
        String lang = "tac";

        WordPairReader wpr = new WordPairReader(dir + lang + "/candlines.txt", dir+lang+"/align-fa/condprob.txt");
    }

}
